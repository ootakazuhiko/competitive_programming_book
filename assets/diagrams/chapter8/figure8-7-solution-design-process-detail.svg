<svg viewBox="0 0 950 1200" xmlns="http://www.w3.org/2000/svg" style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
  <defs>
    <style>
      .header { font-size: 16px; font-weight: 600; fill: var(--text-primary, #1a1a1a); }
      .stage-title { font-size: 14px; font-weight: 600; fill: var(--text-primary, #1a1a1a); }
      .item-text { font-size: 12px; fill: var(--text-secondary, #4a4a4a); }
      .code-text { font-size: 10px; fill: var(--text-tertiary, #666666); font-family: 'Monaco', 'Consolas', monospace; }
      .highlight-text { font-size: 11px; fill: var(--success-text, #059669); font-weight: 500; }
      .step-text { font-size: 11px; fill: var(--text-tertiary, #666666); }
      .warning-text { font-size: 11px; fill: var(--error-text, #dc2626); }
      .box { fill: var(--bg-primary, #ffffff); stroke: var(--border-primary, #d1d5db); stroke-width: 1.5; }
      .header-box { fill: var(--bg-accent, #f3f4f6); stroke: var(--border-primary, #d1d5db); stroke-width: 1.5; }
      .problem-box { fill: var(--bg-info, #e8f5ff); stroke: var(--border-info, #3b82f6); stroke-width: 1.5; }
      .stage1-box { fill: var(--bg-warning, #fffaf0); stroke: var(--border-warning, #f59e0b); stroke-width: 1.5; }
      .stage2-box { fill: var(--bg-success, #f0f9f5); stroke: var(--border-success, #10b981); stroke-width: 1.5; }
      .stage3-box { fill: var(--bg-purple, #f3e8ff); stroke: var(--border-purple, #8b5cf6); stroke-width: 1.5; }
      .stage4-box { fill: var(--bg-cyan, #ecfdf5); stroke: var(--border-cyan, #06b6d4); stroke-width: 1.5; }
      .stage5-box { fill: var(--bg-rose, #fef2f2); stroke: var(--border-rose, #ef4444); stroke-width: 1.5; }
      .arrow { fill: none; stroke: var(--text-tertiary, #666666); stroke-width: 2; marker-end: url(#arrowhead); }
    </style>
    <defs>
      <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
        <polygon points="0 0, 10 3.5, 0 7" fill="var(--text-tertiary, #666666)"/>
      </marker>
    </defs>
  </defs>

  <!-- Title -->
  <rect x="20" y="20" width="910" height="40" class="header-box" rx="8"/>
  <text x="475" y="44" text-anchor="middle" class="header">🎯 実際の問題での解法設計プロセス</text>

  <!-- Problem Statement -->
  <rect x="40" y="80" width="870" height="100" class="problem-box" rx="8"/>
  <text x="60" y="104" class="stage-title">📋 問題：「文字列の最長共通部分文字列」</text>
  <text x="80" y="128" class="item-text">2つの文字列S1, S2が与えられます。S1とS2の最長共通部分文字列の長さを求めてください。</text>
  <text x="80" y="148" class="item-text">制約：1 ≤ |S1|, |S2| ≤ 1000 　サンプル：abcdef, cdefgh → 4 (cdefが共通)</text>

  <!-- Stage 1: Problem Abstraction -->
  <rect x="40" y="200" width="870" height="180" class="stage1-box" rx="8"/>
  <text x="60" y="224" class="stage-title">🎯 Stage 1: 問題の抽象化</text>
  
  <text x="80" y="248" class="item-text">分類：文字列問題 + 動的プログラミング</text>
  
  <text x="80" y="278" class="item-text">類似問題：</text>
  <text x="100" y="298" class="step-text">• 最長共通部分列（LCS）</text>
  <text x="100" y="318" class="step-text">• 編集距離（Levenshtein distance）</text>
  <text x="100" y="338" class="step-text">• 文字列マッチング</text>
  
  <text x="480" y="278" class="item-text">特徴：</text>
  <text x="500" y="298" class="step-text">• 2つの文字列の比較</text>
  <text x="500" y="318" class="step-text">• 部分文字列（連続）が重要</text>
  <text x="500" y="338" class="step-text">• 最適化問題（最長を求める）</text>
  
  <text x="80" y="358" class="highlight-text">🎯 適用可能：動的プログラミング（DP）、全探索</text>

  <!-- Arrow 1 -->
  <path d="M 475 380 L 475 410" class="arrow"/>

  <!-- Stage 2: Constraint Analysis -->
  <rect x="40" y="400" width="870" height="140" class="stage2-box" rx="8"/>
  <text x="60" y="424" class="stage-title">📊 Stage 2: 制約分析</text>
  
  <text x="80" y="448" class="item-text">制約：|S1|, |S2| ≤ 1000</text>
  
  <text x="80" y="478" class="item-text">計算量見積もり：</text>
  <text x="100" y="498" class="warning-text">• 全探索：O(|S1|² × |S2|²) = O(10¹²) → TLE</text>
  <text x="100" y="518" class="highlight-text">• DP：O(|S1| × |S2|) = O(10⁶) → 安全</text>
  
  <text x="500" y="478" class="item-text">メモリ使用量：</text>
  <text x="520" y="498" class="step-text">• DP表：1000 × 1000 = 10⁶個</text>
  <text x="520" y="518" class="step-text">• 約4MB → 問題なし</text>

  <!-- Arrow 2 -->
  <path d="M 475 540 L 475 570" class="arrow"/>

  <!-- Stage 3: Data Structure Selection -->
  <rect x="40" y="560" width="870" height="160" class="stage3-box" rx="8"/>
  <text x="60" y="584" class="stage-title">🗂️ Stage 3: データ構造の選択</text>
  
  <text x="80" y="608" class="item-text">必要なデータ構造：</text>
  <text x="100" y="628" class="step-text">• 入力文字列：string（そのまま）</text>
  <text x="100" y="648" class="step-text">• DP表：2次元リスト（int）</text>
  
  <text x="480" y="608" class="item-text">DP表の定義：</text>
  <text x="500" y="628" class="step-text">dp[i][j] = S1[0:i]とS2[0:j]の最長共通部分文字列長</text>
  
  <text x="80" y="678" class="item-text">更新式：</text>
  <text x="100" y="698" class="highlight-text">• S1[i-1] == S2[j-1]の場合：dp[i][j] = dp[i-1][j-1] + 1</text>
  <text x="100" y="708" class="step-text">• 異なる場合：dp[i][j] = 0</text>

  <!-- Arrow 3 -->
  <path d="M 475 720 L 475 750" class="arrow"/>

  <!-- Stage 4: Pseudocode -->
  <rect x="40" y="740" width="870" height="200" class="stage4-box" rx="8"/>
  <text x="60" y="764" class="stage-title">📝 Stage 4: 疑似コード作成</text>
  
  <rect x="60" y="780" width="400" height="140" class="box" rx="4"/>
  <text x="80" y="800" class="code-text">1. S1, S2 を入力</text>
  <text x="80" y="820" class="code-text">2. dp = [[0] * (len2+1) for _ in range(len1+1)]</text>
  <text x="80" y="840" class="code-text">3. for i in range(1, len1+1):</text>
  <text x="100" y="860" class="code-text">for j in range(1, len2+1):</text>
  <text x="120" y="880" class="code-text">if S1[i-1] == S2[j-1]:</text>
  <text x="140" y="900" class="code-text">dp[i][j] = dp[i-1][j-1] + 1</text>
  
  <text x="480" y="800" class="item-text">サンプルでの動作確認：</text>
  <text x="500" y="820" class="step-text">S1="abcdef", S2="cdefgh"</text>
  <text x="500" y="840" class="step-text">i=3,j=1: 'c'=='c' → dp[3][1]=1</text>
  <text x="500" y="860" class="step-text">i=4,j=2: 'd'=='d' → dp[4][2]=2</text>
  <text x="500" y="880" class="step-text">i=5,j=3: 'e'=='e' → dp[5][3]=3</text>
  <text x="500" y="900" class="step-text">i=6,j=4: 'f'=='f' → dp[6][4]=4</text>
  <text x="500" y="920" class="highlight-text">max_length = 4 ✅</text>

  <!-- Arrow 4 -->
  <path d="M 475 940 L 475 970" class="arrow"/>

  <!-- Stage 5: Implementation Strategy -->
  <rect x="40" y="960" width="870" height="200" class="stage5-box" rx="8"/>
  <text x="60" y="984" class="stage-title">🔧 Stage 5: 実装とテスト戦略</text>
  
  <text x="80" y="1008" class="item-text">実装順序：</text>
  <text x="100" y="1028" class="step-text">1. 入力処理とDP表の初期化</text>
  <text x="100" y="1048" class="step-text">2. 二重ループの骨組み</text>
  <text x="100" y="1068" class="step-text">3. 文字比較と更新ロジック</text>
  <text x="100" y="1088" class="step-text">4. 最大値の追跡と出力</text>
  
  <text x="480" y="1008" class="item-text">テスト項目：</text>
  <text x="500" y="1028" class="step-text">✅ サンプルケースで正しい結果</text>
  <text x="500" y="1048" class="step-text">✅ 同じ文字列同士の場合</text>
  <text x="500" y="1068" class="step-text">✅ 完全に異なる文字列の場合</text>
  <text x="500" y="1088" class="step-text">✅ エッジケース（空文字列等）</text>
  
  <text x="80" y="1128" class="item-text">デバッグ支援：DP表の中身をprintで確認、各ステップでmax_lengthの値を確認</text>

  <!-- Key Learning -->
  <rect x="40" y="1180" width="870" height="40" class="header-box" rx="8"/>
  <text x="60" y="1204" class="stage-title">🎯 体系的な解法設計で複雑な問題も段階的に攻略できる</text>
</svg>