# 第9章：エラーと上手に付き合おう

## 9.1 よくあるエラーメッセージを覚えよう

第8章では体系的な問題解決プロセスを学んだね。でも実際にプログラムを書いていると、必ずエラーに遭遇する。エラーは敵ではなく、プログラムを正しくするためのヒントをくれる「味方」なんだ。

```
【図9-1：エラーメッセージとの正しい関係】

😱 初心者の頃のエラーとの関係
┌─────────────────────────────────────────────┐
│ エラーが出た！                              │
│    ↓                                      │
│ パニック・諦めモード                        │
│    ↓                                      │
│ なんとなく修正                             │
│    ↓                                      │
│ また別のエラー...                           │
│    ↓                                      │
│ 😵 無限ループ                              │
└─────────────────────────────────────────────┘

😊 上級者のエラーとの関係
┌─────────────────────────────────────────────┐
│ エラーが出た！                              │
│    ↓                                      │
│ 「よし、ヒントをもらった！」                │
│    ↓                                      │
│ エラーメッセージを読解                      │
│    ↓                                      │
│ 原因を特定して的確に修正                    │
│    ↓                                      │
│ 😄 問題解決！スキルアップ！                 │
└─────────────────────────────────────────────┘
```

### Python競技プログラミングでの頻出エラー TOP5

```
【図9-2：エラーメッセージ頻出ランキング】

🥇 第1位：SyntaxError（構文エラー）
┌─────────────────────────────────────────────┐
│ 📊 発生頻度：40%                            │
│ 🎯 原因：文法のミス                          │
│                                           │
│ よくあるパターン：                          │
│ ❌ コロン(:)の忘れ                          │
│ if x > 0                  # ← :がない       │
│     print("positive")                      │
│                                           │
│ ❌ 括弧の対応間違い                         │
│ print("Hello World"       # ← )がない      │
│                                           │
│ ❌ インデントのずれ                         │
│ if x > 0:                                  │
│ print("positive")         # ← インデントなし│
│                                           │
│ ✅ 正しい書き方：                           │
│ if x > 0:                 # コロンあり     │
│     print("positive")     # インデント4空白 │
└─────────────────────────────────────────────┘

🥈 第2位：NameError（名前エラー）
┌─────────────────────────────────────────────┐
│ 📊 発生頻度：25%                            │
│ 🎯 原因：変数名の間違い                      │
│                                           │
│ よくあるパターン：                          │
│ ❌ 変数名のタイプミス                       │
│ number = 5                                 │
│ print(nubmer)             # ← スペルミス    │
│                                           │
│ ❌ 定義前の使用                            │
│ print(result)             # ← まだ定義してない│
│ result = 42                                │
│                                           │
│ ✅ 対策：                                  │
│ • 変数名は短く、意味のある名前にする         │
│ • 定義してから使用する                     │
│ • エディタの補完機能を活用                  │
└─────────────────────────────────────────────┘

🥉 第3位：IndexError（インデックスエラー）
┌─────────────────────────────────────────────┐
│ 📊 発生頻度：20%                            │
│ 🎯 原因：リストの範囲外アクセス               │
│                                           │
│ よくあるパターン：                          │
│ ❌ 配列サイズを超えたアクセス                │
│ arr = [1, 2, 3]           # 長さ3の配列     │
│ print(arr[3])             # ← インデックス3は存在しない│
│                                           │
│ ❌ 空リストへのアクセス                     │
│ empty_list = []                            │
│ print(empty_list[0])      # ← 何もないのにアクセス│
│                                           │
│ ✅ 安全なアクセス方法：                     │
│ if len(arr) > 3:                           │
│     print(arr[3])                          │
│ else:                                      │
│     print("インデックス3は存在しません")      │
└─────────────────────────────────────────────┘
```

### エラーメッセージの読み方をマスターしよう

```
【図9-3：エラーメッセージ解読の技術】

🔍 Traceback（トレースバック）の読み方
┌─────────────────────────────────────────────┐
│ 実際のエラー例：                            │
│                                           │
│ Traceback (most recent call last):         │
│   File "solution.py", line 7, in <module>  │
│     result = 10 / zero_value               │
│ ZeroDivisionError: division by zero        │
│                                           │
│ 📖 読み方ガイド：                          │
│                                           │
│ ①「File "solution.py", line 7」            │
│   → solution.pyファイルの7行目でエラー      │
│                                           │
│ ②「result = 10 / zero_value」              │
│   → この行でエラーが発生                   │
│                                           │
│ ③「ZeroDivisionError: division by zero」   │
│   → エラーの種類：ゼロで割り算しようとした   │
│                                           │
│ 💡 対処法：                                │
│ 7行目の zero_value が0になっていないか確認  │
└─────────────────────────────────────────────┘

🎯 エラーメッセージから原因を特定する手順
┌─────────────────────────────────────────────┐
│ Step 1: エラーの種類を確認                   │
│ • SyntaxError → 文法ミス                   │
│ • NameError → 変数名ミス                   │
│ • IndexError → 配列の範囲外アクセス         │
│ • ZeroDivisionError → ゼロ除算             │
│                                           │
│ Step 2: エラー発生行を特定                   │
│ • 「line X」でX行目を確認                  │
│ • その行とその前後を詳しく見る              │
│                                           │
│ Step 3: 具体的な原因を推測                   │
│ • 変数の値が予想と違っていないか？           │
│ • 条件分岐で想定外のケースに入っていないか？  │
│ • 計算式に問題はないか？                   │
│                                           │
│ Step 4: 仮説を立てて修正                     │
│ • print文で変数の値を確認                  │
│ • 一つずつ修正して動作確認                  │
└─────────────────────────────────────────────┘
```

## 9.2 実行時エラーを解決しよう

構文エラーはエディタで気づきやすいけれど、実行時エラーは実際にプログラムを動かしてみないと分からない。でも、パターンを覚えれば対処は意外と簡単なんだ。

```
【図9-4：実行時エラーの体系的対処法】

🔍 実行時エラーの分類と対策

❌ ZeroDivisionError（ゼロ除算エラー）
┌─────────────────────────────────────────────┐
│ 💡 エラーの原因：                           │
│ 0で数値を割ろうとした                       │
│                                           │
│ 🚨 問題のあるコード：                       │
│ a = int(input())                           │
│ b = int(input())                           │
│ print(a / b)              # bが0の場合エラー │
│                                           │
│ ✅ 改善されたコード：                       │
│ a = int(input())                           │
│ b = int(input())                           │
│ if b != 0:                                 │
│     print(a / b)                           │
│ else:                                      │
│     print("0で割ることはできません")         │
│                                           │
│ 🎯 対策のポイント：                         │
│ • 除算の前に分母が0でないかチェック          │
│ • 入力データの検証を習慣にする              │
└─────────────────────────────────────────────┘

❌ ValueError（値エラー）
┌─────────────────────────────────────────────┐
│ 💡 エラーの原因：                           │
│ 数値に変換できない文字列を変換しようとした    │
│                                           │
│ 🚨 問題のあるコード：                       │
│ text = "abc"                               │
│ number = int(text)        # "abc"は数値じゃない│
│                                           │
│ ✅ 改善されたコード：                       │
│ text = input()                             │
│ if text.isdigit():        # 数字かチェック  │
│     number = int(text)                     │
│     print(f"数値: {number}")                │
│ else:                                      │
│     print("数値ではありません")             │
│                                           │
│ 🎯 対策のポイント：                         │
│ • 変換前にデータの妥当性をチェック           │
│ • isdigit()メソッドで数字かどうか判定        │
└─────────────────────────────────────────────┘

❌ TypeError（型エラー）
┌─────────────────────────────────────────────┐
│ 💡 エラーの原因：                           │
│ 異なる型同士で演算しようとした              │
│                                           │
│ 🚨 問題のあるコード：                       │
│ number = 5                                 │
│ text = "3"                                 │
│ result = number + text    # 数値と文字列を足し算│
│                                           │
│ ✅ 改善されたコード：                       │
│ number = 5                                 │
│ text = "3"                                 │
│ result = number + int(text)  # 文字列を数値に変換│
│ print(result)             # 8               │
│                                           │
│ 🎯 対策のポイント：                         │
│ • 演算前に型を統一する                     │
│ • int(), str(), float()で明示的に変換       │
└─────────────────────────────────────────────┘
```

### デバッグの実践的テクニック

```
【図9-5：print文デバッグの効果的活用法】

🔧 段階的デバッグの手順

問題のあるコード例：
def calculate_average(numbers):
    total = 0
    for num in numbers:
        total += num
    return total / len(numbers)

arr = [10, 20, 30]
result = calculate_average(arr)
print(result)

↓ デバッグ版に改造

def calculate_average(numbers):
    print(f"Debug: 受け取った配列 = {numbers}")  # ①入力確認
    
    total = 0
    for i, num in enumerate(numbers):
        total += num
        print(f"Debug: {i+1}回目, num={num}, total={total}")  # ②処理過程確認
    
    print(f"Debug: 最終的なtotal = {total}")     # ③中間結果確認
    print(f"Debug: 配列の長さ = {len(numbers)}")  # ④計算要素確認
    
    result = total / len(numbers)
    print(f"Debug: 計算結果 = {result}")         # ⑤最終結果確認
    
    return result

🎯 デバッグprintの効果的な書き方：
┌─────────────────────────────────────────────┐
│ ✅ 良いデバッグprint：                      │
│ print(f"Debug: 変数名={変数の値}")           │
│ print(f"Step 1: ここまで到達しました")       │
│ print(f"Loop {i}: x={x}, y={y}")            │
│                                           │
│ ❌ 分かりにくいデバッグprint：               │
│ print(x)                  # 何の値か不明   │
│ print("ここ")              # どこの"ここ"?  │
│ print(123)               # 意味不明な数値  │
│                                           │
│ 💡 コツ：                                  │
│ • "Debug:"をつけて本来の出力と区別          │
│ • 変数名と値をセットで表示                  │
│ • どの段階の処理かを明記                   │
└─────────────────────────────────────────────┘
```

## 9.3 論理エラーを見つけよう

最も厄介なのが論理エラーだ。プログラムは動くけれど、期待した結果にならない。これはプログラマーの考え方とコンピューターの動作にずれがあるときに起こる。

```
【図9-6：論理エラーの発見・修正プロセス】

🕵️ 論理エラーの特徴
┌─────────────────────────────────────────────┐
│ • エラーメッセージが出ない                   │
│ • プログラムは最後まで実行される             │
│ • でも出力が期待と違う                      │
│ • 一番発見が困難で修正に時間がかかる         │
│                                           │
│ 例：「配列の最大値を求める」プログラム        │
│                                           │
│ 🚨 バグのあるコード：                       │
│ def find_max(arr):                         │
│     max_val = 0           # ⚠️ 初期値が間違い│
│     for num in arr:                        │
│         if num > max_val:                  │
│             max_val = num                  │
│     return max_val                         │
│                                           │
│ # テスト                                   │
│ print(find_max([3, 1, 4]))  # 期待:4, 実際:4 ✅│
│ print(find_max([-1, -5, -2])) # 期待:-1, 実際:0 ❌│
│                                           │
│ 🐛 問題：全要素が負数の場合、初期値0が返される│
└─────────────────────────────────────────────┘

🔍 手動トレースによる原因発見
┌─────────────────────────────────────────────┐
│ 📝 find_max([-1, -5, -2])の動作を追跡：      │
│                                           │
│ Step 1: max_val = 0 で初期化               │
│ Step 2: num = -1, -1 > 0? → False         │
│ Step 3: num = -5, -5 > 0? → False         │
│ Step 4: num = -2, -2 > 0? → False         │
│ Step 5: return 0                          │
│                                           │
│ 💡 発見：初期値が0だと、負数が全て無視される  │
│                                           │
│ ✅ 修正版：                                │
│ def find_max(arr):                         │
│     max_val = arr[0]      # 最初の要素で初期化│
│     for num in arr[1:]:   # 2番目から開始   │
│         if num > max_val:                  │
│             max_val = num                  │
│     return max_val                         │
└─────────────────────────────────────────────┘

🧪 境界値テストによる検証
┌─────────────────────────────────────────────┐
│ 🎯 テストケース設計：                       │
│                                           │
│ ✅ 正常ケース：                            │
│ • [1, 2, 3, 4, 5] → 5                     │
│ • [10, 5, 8] → 10                         │
│                                           │
│ ✅ 境界ケース：                            │
│ • [5] → 5（単一要素）                      │
│ • [-1, -2, -3] → -1（全負数）             │
│ • [0, 0, 0] → 0（全ゼロ）                 │
│                                           │
│ ✅ 特殊ケース：                            │
│ • [100, -50, 200] → 200（正負混在）        │
│ • [5, 5, 5] → 5（同値）                   │
│                                           │
│ 💡 テストの考え方：                        │
│ • 期待される動作ケース                     │
│ • 想定外の入力パターン                     │
│ • 数学的に特別な意味を持つ値                │
└─────────────────────────────────────────────┘
```

### 逆算チェックの技法

```
【図9-7：期待される出力からの逆算検証】

🔍 逆算チェックの手順

例題：「配列の合計がKになる部分配列の個数」
入力：arr=[1,2,3,4], K=5
期待出力：2

📝 逆算による検証：
┌─────────────────────────────────────────────┐
│ Step 1: 期待される結果を手動で計算           │
│                                           │
│ 部分配列とその合計を全列挙：                │
│ • [1]: 合計1                              │
│ • [2]: 合計2                              │
│ • [3]: 合計3                              │
│ • [4]: 合計4                              │
│ • [1,2]: 合計3                            │
│ • [2,3]: 合計5 ✅                         │
│ • [3,4]: 合計7                            │
│ • [1,2,3]: 合計6                          │
│ • [2,3,4]: 合計9                          │
│ • [1,2,3,4]: 合計10                       │
│                                           │
│ K=5になる部分配列：[2,3]のみ               │
│ 正解：1個（期待出力2と異なる）              │
│                                           │
│ Step 2: 問題文の再確認                      │
│ 問題文をもう一度読み直す → 理解の間違い発見  │
│                                           │
│ Step 3: プログラムロジックの見直し           │
│ コードが手動計算と同じ処理をしているか確認    │
└─────────────────────────────────────────────┘
```

## 9.4 AtCoderでの「Wrong Answer」対策

競技プログラミング特有のエラー「Wrong Answer（WA）」は、プログラムは動くが期待される出力と異なる結果を出力した時に出る。これを解決するコツを覚えよう。

```
【図9-8：Wrong Answer の体系的対処法】

❌ Wrong Answer（WA）が出た時の分析手順

🔍 Step 1: 出力形式の厳密確認
┌─────────────────────────────────────────────┐
│ AtCoderでよくある出力形式ミス：              │
│                                           │
│ ❌ 余分な改行：                            │
│ print("答え")                              │
│ print()                   # 不要な空行     │
│                                           │
│ ❌ 区切り文字の間違い：                     │
│ print(a, b, c, sep=',')   # コンマ区切り   │
│ # 問題文では空白区切りが正解                │
│                                           │
│ ❌ 大文字小文字の間違い：                   │
│ print("yes")              # 小文字で出力   │
│ # 問題文では"Yes"が要求                    │
│                                           │
│ ❌ 数値の桁数・精度：                       │
│ print(3.14)               # 小数点以下2桁  │
│ # 問題文では整数出力が要求                  │
│                                           │
│ ✅ 対策：                                  │
│ • 問題文の出力例を文字単位で確認            │
│ • print()の引数を慎重にチェック             │
│ • サンプル出力との完全一致を確認            │
└─────────────────────────────────────────────┘

🔍 Step 2: 計算ロジックの段階的検証
┌─────────────────────────────────────────────┐
│ デバッグ出力による検証手順：                │
│                                           │
│ # 元のコード                               │
│ n = int(input())                           │
│ arr = list(map(int, input().split()))      │
│ result = some_calculation(arr)             │
│ print(result)                              │
│                                           │
│ # デバッグ版（提出前に削除すること）         │
│ import sys                                 │
│ n = int(input())                           │
│ arr = list(map(int, input().split()))      │
│ print(f"Debug: n={n}, arr={arr}", file=sys.stderr)│
│ result = some_calculation(arr)             │
│ print(f"Debug: result={result}", file=sys.stderr)│
│ print(result)              # 本来の出力    │
│                                           │
│ 💡 sys.stderr への出力はジャッジに影響しない │
│ 💡 提出前にはデバッグ文をすべて削除する      │
└─────────────────────────────────────────────┘

🔍 Step 3: エッジケースの網羅的確認
┌─────────────────────────────────────────────┐
│ チェックすべきエッジケース：                │
│                                           │
│ 🎯 サイズ関連：                            │
│ • N=1（最小ケース）                        │
│ • N=制約上限（計算量は大丈夫？）            │
│                                           │
│ 🎯 値関連：                               │
│ • 全要素が同じ値                           │
│ • 最小値・最大値が境界                      │
│ • 負数・ゼロの扱い                         │
│                                           │
│ 🎯 構造関連：                              │
│ • ソート済み・逆順データ                   │
│ • 重複要素の存在                           │
│ • 空集合・単一要素                         │
│                                           │
│ 📝 自作テストケース例：                     │
│ # 最小ケース                               │
│ 1                                          │
│ 5                                          │
│                                           │
│ # 重複ケース                               │
│ 3                                          │
│ 2 2 2                                      │
│                                           │
│ # 境界値ケース                             │
│ 2                                          │
│ 1000000000 1000000000                     │
└─────────────────────────────────────────────┘
```

### AtCoder特有のトラブルシューティング

```
【図9-9：AtCoder提出時のよくある失敗と対策】

🚨 提出時のチェックリスト

✅ 提出前の最終確認：
┌─────────────────────────────────────────────┐
│ □ 言語選択が「Python (CPython 3.x)」になっているか│
│ □ デバッグ用のprint文をすべて削除したか         │
│ □ コード全体を正しくコピー&ペーストしたか        │
│ □ サンプルケースで動作確認済みか               │
│ □ 出力形式が問題文の要求と完全一致するか        │
│                                           │
│ 🎯 言語選択のミス：                        │
│ • 間違ってPyPyを選んでしまうことがある        │
│ • Python2.7を選んでしまうと文法エラー        │
│                                           │
│ 🎯 コピペミス：                            │
│ • 一部のコードが欠けている                  │
│ • 余分な文字が混入している                  │
│                                           │
│ 🎯 デバッグ文の残存：                       │
│ • print("Debug: ...")が残っている           │
│ • 本来の出力以外が表示される                │
└─────────────────────────────────────────────┘

🔧 WA時の段階的対処法：
┌─────────────────────────────────────────────┐
│ Phase 1: 出力形式の再確認（5分以内）         │
│ • サンプル出力を1文字ずつ照合               │
│ • 改行、空白、大文字小文字を厳密チェック      │
│                                           │
│ Phase 2: サンプルケースでの手動追跡（10分以内）│
│ • 自分の手で計算した結果と比較              │
│ • 中間過程をすべて確認                     │
│                                           │
│ Phase 3: エッジケースでの動作確認（15分以内） │
│ • 自作テストケースで動作確認                │
│ • 境界値での計算ミスがないかチェック         │
│                                           │
│ Phase 4: アルゴリズム自体の見直し（残り時間）│
│ • そもそもの解法が間違っていないか？         │
│ • より確実な解法に変更する判断も必要         │
└─────────────────────────────────────────────┘
```

## 9.5 「Time Limit Exceeded」を解決しよう

TLE（Time Limit Exceeded）は、プログラムの実行時間が制限時間を超えた時に出るエラーだ。正しい答えは出るけれど、計算に時間がかかりすぎるということ。

```
【図9-10：TLE対策の段階的アプローチ】

⏰ TLE（Time Limit Exceeded）の原因分析

🔍 原因1: アルゴリズムの計算量が過大
┌─────────────────────────────────────────────┐
│ よくある問題パターン：                      │
│                                           │
│ ❌ 不要な二重ループ：                       │
│ for i in range(n):                         │
│     for j in range(n):                     │
│         if arr[i] == target:  # 内側で毎回同じチェック│
│             count += 1                     │
│ # 計算量：O(N²) → N=100,000なら100億回計算  │
│                                           │
│ ✅ 改善版：                                │
│ count = 0                                  │
│ for x in arr:                              │
│     if x == target:                        │
│         count += 1                         │
│ # 計算量：O(N) → N=100,000なら10万回計算    │
│                                           │
│ 💡 改善のポイント：                        │
│ • 不要な重複処理を削除                     │
│ • 一度の処理で済ませられることは一度だけ     │
└─────────────────────────────────────────────┘

🔍 原因2: 非効率なデータ構造の使用
┌─────────────────────────────────────────────┐
│ ❌ リストでの検索（O(N)）：                  │
│ def count_occurrences(arr, target):        │
│     count = 0                              │
│     for x in arr:                          │
│         if x == target:                    │
│             count += 1                     │
│     return count                           │
│                                           │
│ # 毎回O(N)の検索が発生                      │
│ for target in queries:                     │
│     result = count_occurrences(arr, target)│
│ # 全体でO(N×M) → 場合によっては数十億回計算  │
│                                           │
│ ✅ 辞書を使った高速化（O(1)）：              │
│ from collections import Counter            │
│ counter = Counter(arr)    # O(N)で前処理   │
│ for target in queries:                     │
│     result = counter[target]  # O(1)で取得 │
│ # 全体でO(N+M) → 大幅な高速化               │
└─────────────────────────────────────────────┘

🔍 原因3: Python特有のパフォーマンス問題
┌─────────────────────────────────────────────┐
│ ❌ 遅い書き方：                            │
│ result = []                                │
│ for i in range(n):                         │
│     result.append(str(arr[i]))             │
│ output = '\n'.join(result)                 │
│                                           │
│ ✅ 高速化テクニック：                       │
│ # リスト内包表記の使用                      │
│ result = [str(x) for x in arr]             │
│ output = '\n'.join(result)                 │
│                                           │
│ # さらに高速化                             │
│ output = '\n'.join(map(str, arr))          │
│                                           │
│ # 大量出力の場合のさらなる最適化             │
│ import sys                                 │
│ for x in arr:                              │
│     sys.stdout.write(str(x) + '\n')       │
└─────────────────────────────────────────────┘
```

### 計算量の見積もりと改善

```
【図9-11：制約から計算量を逆算する技術】

📊 制約と許容される計算量の目安
┌─────────────────────────────────────────────┐
│ N ≤ 10        → あらゆるアルゴリズム使用可能  │
│ N ≤ 20        → O(2^N)の全探索も可能         │
│ N ≤ 100       → O(N^3)まで                 │
│ N ≤ 1,000     → O(N^2)まで                 │
│ N ≤ 100,000   → O(N log N)まで             │
│ N ≤ 1,000,000 → O(N)まで                   │
│                                           │
│ 💡 安全マージンの考え方：                   │
│ • 見積もりの2-3倍の余裕を見る               │
│ • Pythonは他言語より3-5倍遅いことを考慮      │
│ • 実装の複雑さも計算量に影響する            │
│                                           │
│ 🎯 判断例：                               │
│ N≤1000の制約で二重ループ（O(N^2)）は安全    │
│ N≤100000で二重ループはTLEの危険性大        │
└─────────────────────────────────────────────┘

🚀 高速化チェックリスト
┌─────────────────────────────────────────────┐
│ ✅ アルゴリズムの計算量見直し：              │
│ • 全探索 → 二分探索・ハッシュ活用           │
│ • 毎回計算 → 前処理・メモ化                │
│ • 重複処理 → 一度だけの処理に変更           │
│                                           │
│ ✅ データ構造の最適化：                     │
│ • リスト検索 → 辞書・集合活用              │
│ • 文字列結合 → join使用                   │
│ • 動的配列 → 事前サイズ確保                │
│                                           │
│ ✅ Python固有の最適化：                    │
│ • for文 → リスト内包表記                  │
│ • 関数呼び出し回数削減                     │
│ • import文の効率化                        │
│                                           │
│ ✅ 最後の手段：                           │
│ • PyPy での提出（通常の Python より高速）   │
│ • アルゴリズム自体の根本的見直し            │
│ • 問題の制約をもう一度確認                  │
└─────────────────────────────────────────────┘
```

### TLE解決の実践例

```
【図9-12：実際のTLE解決プロセス】

🎯 例題：「N個の数から2つ選んで積がKになるペアの個数」

❌ TLEするコード（O(N²)）：
┌─────────────────────────────────────────────┐
│ n, k = map(int, input().split())             │
│ arr = list(map(int, input().split()))        │
│                                           │
│ count = 0                                  │
│ for i in range(n):                         │
│     for j in range(i+1, n):               │
│         if arr[i] * arr[j] == k:           │
│             count += 1                     │
│ print(count)                               │
│                                           │
│ 問題：N=100,000の場合、約50億回の計算        │
│ → 明らかにTLE                              │
└─────────────────────────────────────────────┘

✅ 高速化されたコード（O(N)）：
┌─────────────────────────────────────────────┐
│ from collections import Counter            │
│ n, k = map(int, input().split())           │
│ arr = list(map(int, input().split()))      │
│                                           │
│ counter = Counter(arr)                     │
│ count = 0                                  │
│                                           │
│ for num in counter:                        │
│     if k % num == 0:      # numで割り切れる場合│
│         partner = k // num                 │
│         if partner in counter:             │
│             if num == partner:             │
│                 # 同じ数同士のペア          │
│                 count += counter[num] * (counter[num] - 1) // 2│
│             elif num < partner:            │
│                 # 異なる数のペア            │
│                 count += counter[num] * counter[partner]│
│ print(count)                               │
│                                           │
│ 改善：N=100,000でも10万回程度の計算で完了    │
└─────────────────────────────────────────────┘
```

## まとめ：エラーは成長への階段

この章では、プログラミングで避けて通れないエラーとの正しい付き合い方を学んだね。

```
【図9-13：この章で身につけたエラー対応力】

🛠️ 習得したスキル
┌─────────────────────────────────────────────┐
│ ✅ エラーメッセージの正確な読解              │
│ ✅ 段階的デバッグによる原因特定              │
│ ✅ 論理エラーの発見と修正技法               │
│ ✅ AtCoder特有の問題への対処法              │
│ ✅ TLE対策と計算量最適化                   │
└─────────────────────────────────────────────┘

🧠 身についた考え方
┌─────────────────────────────────────────────┐
│ • エラーは「敵」ではなく「成長への手がかり」  │
│ • 問題を段階的に分解して解決する習慣        │
│ • 仮説を立てて検証するサイクル              │
│ • あきらめずに原因を追究する粘り強さ        │
└─────────────────────────────────────────────┘

🚀 次のステップ
┌─────────────────────────────────────────────┐
│ 第10章: コンテストに参加してみよう           │
│ • 学んだエラー対応力の実戦での活用           │
│ • 時間制限下での効率的なデバッグ            │
│ • コンテスト特有の環境での問題解決           │
└─────────────────────────────────────────────┘
```

**エラーとの正しい関係を築けた君へ**

エラーに遭遇したとき、もうパニックになることはないはずだ。エラーメッセージを冷静に読み、段階的に原因を特定し、的確に修正する。この技術は、競技プログラミングだけでなく、将来プロのエンジニアになったときにも必ず役立つ。

**実戦での活用に向けて**

次の章では、いよいよ実際のAtCoderコンテストに参加する方法を学ぶよ。君が身につけたエラー対応力を、時間制限のあるコンテストでどう活用するか、実戦的なコツを身につけよう！