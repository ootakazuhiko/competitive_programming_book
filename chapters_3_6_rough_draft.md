# 第3-6章ラフ原稿（基礎・技術習得編）

## 第3章：プログラミング環境を整えよう

### 章の目的
AtCoderで実際にプログラムを書いて提出するための実践的な環境を構築する

### 3.1 なぜPythonを選ぶの？

**Scratchとの共通点を活用した動機付け**

```
【図3-1：ScratchからPythonへの自然な進化】

Scratchの良いところ          Pythonで受け継がれること
┌─────────────────┐      ┌─────────────────┐
│ 📝 分かりやすい日本語   │  →   │ 📝 読みやすい英語      │
│ 🧩 直感的なブロック組み │  →   │ 🧩 直感的な文法構造    │
│ 🎮 すぐに結果が見える   │  →   │ 🎮 インタラクティブ実行 │
│ 🔧 豊富な機能ブロック   │  →   │ 🔧 豊富なライブラリ    │
└─────────────────┘      └─────────────────┘

Pythonの競技プログラミング向けメリット：
✅ 学習コストが低い（Scratchユーザーには特に）
✅ コードが短く書ける（入力処理が簡単）
✅ AtCoderで正式サポート（実行時間も十分）
✅ エラーメッセージが分かりやすい
```

**他言語との比較（中学生向け説明）**

```
【図3-2：主要言語の中学生にとっての難易度比較】

      学習難易度    コード量    競技適性
Python    ⭐⭐☆     ⭐⭐☆     ⭐⭐⭐  ← おすすめ！
C++       ⭐⭐⭐     ⭐⭐⭐     ⭐⭐⭐  ← 上級者向け
Java      ⭐⭐⭐     ⭐⭐⭐     ⭐⭐☆  ← 企業開発向け
JavaScript ⭐⭐☆     ⭐⭐☆     ⭐☆☆  ← Web開発向け

💡 中学生がPythonを選ぶべき理由：
• Scratchの「分かりやすさ」を保ったまま本格プログラミングへ
• 競技プログラミングで必要十分な性能
• 将来的にAI・データサイエンス分野でも活用可能
```

### 3.2 Pythonをインストールしよう

**OS別インストール手順（図解重視）**

```
【図3-3：OS別インストール戦略】

🖥️ Windows              🍎 macOS              🐧 Linux
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│ Microsoft Store  │      │ Homebrew推奨     │      │ パッケージマネージャ│
│ または           │      │ または           │      │ apt/yum等使用    │
│ python.org      │      │ python.org      │      │              │
│ からダウンロード   │      │ からダウンロード   │      │              │
└─────────────┘      └─────────────┘      └─────────────┘

共通の確認手順：
1. ターミナル/コマンドプロンプトを開く
2. `python --version` を実行
3. `Python 3.8.x` 以上が表示されればOK！
```

**詳細インストール手順（Windows重点）**

```
【図3-4：Windows Python インストール完全ガイド】

Step 1: ダウンロード
┌─────────────────────────────────────────────┐
│ 🌐 https://python.org にアクセス              │
│ 📥 "Download Python 3.x.x" をクリック         │
│ 💾 ダウンロードフォルダに python-3.x.x.exe   │
└─────────────────────────────────────────────┘

Step 2: インストール実行
┌─────────────────────────────────────────────┐
│ ⚠️ 重要：「Add Python to PATH」にチェック！     │
│ 📦 "Install Now" をクリック                   │
│ ⏱️ 数分待つ（ユーザー権限確認があれば許可）      │
│ ✅ "Setup was successful" が表示されれば完了   │
└─────────────────────────────────────────────┘

Step 3: 動作確認
┌─────────────────────────────────────────────┐
│ 🔍 Windowsキー＋R → "cmd" と入力 → Enter      │
│ ⌨️ `python --version` と入力 → Enter        │
│ 📟 `Python 3.x.x` が表示されれば成功！        │
│                                           │
│ さらに確認：                                │
│ ⌨️ `python` と入力 → Enter                 │
│ 🐍 `>>>` プロンプトが表示されればOK           │
│ ⌨️ `exit()` で終了                         │
└─────────────────────────────────────────────┘
```

### 3.3 エディタを選んで設定しよう

**中学生向けエディタ選択指針**

```
【図3-5：プログラミングエディタ比較（中学生観点）】

           使いやすさ  機能充実度  学習コスト  おすすめ度
VSCode      ⭐⭐⭐     ⭐⭐⭐     ⭐⭐☆     ⭐⭐⭐  
IDLE        ⭐⭐☆     ⭐☆☆     ⭐⭐⭐     ⭐⭐☆  
PyCharm     ⭐⭐☆     ⭐⭐⭐     ⭐☆☆     ⭐⭐☆  
Thonny      ⭐⭐⭐     ⭐⭐☆     ⭐⭐⭐     ⭐⭐⭐  

🎯 初心者には Thonny または VSCode を推奨
```

**VSCode設定詳細ガイド**

```
【図3-6：VSCode 完全セットアップ】

📥 インストール手順
┌─────────────────────────────────────────────┐
│ 1. https://code.visualstudio.com からダウンロード│
│ 2. インストーラーを実行（デフォルト設定でOK）      │
│ 3. 起動後、日本語化（Ctrl+Shift+P → "configure language"）│
└─────────────────────────────────────────────┘

🔌 必須拡張機能インストール
┌─────────────────────────────────────────────┐
│ 📦 Python (Microsoft製) - Python開発支援      │
│ 📦 Python Indent - インデント自動整理         │
│ 📦 Bracket Pair Colorizer - 括弧の色分け      │
│ 📦 Code Runner - ワンクリック実行             │
└─────────────────────────────────────────────┘

⚙️ 競技プログラミング向け設定
┌─────────────────────────────────────────────┐
│ • ファイル自動保存の有効化                     │
│ • フォントサイズ調整（14px推奨）                │
│ • テーマ設定（Dark+推奨、目に優しい）           │
│ • 実行ショートカット設定（F5キー）              │
└─────────────────────────────────────────────┘
```

### 3.4 AtCoderでコードを提出してみよう

**初回提出の完全ガイド**

```
【図3-7：AtCoder初回提出フローチャート】

🎯 練習問題を選ぶ
　　　　↓
📖 問題文を読んで理解
　　　　↓
💻 ローカルでコード作成
　　　　↓
🧪 サンプル入出力でテスト
　　　　↓
📋 AtCoderにコードをコピー
　　　　↓
🚀 提出ボタンをクリック
　　　　↓
⏱️ ジャッジ結果を待つ
　　　　↓
📊 結果分析と改善
```

**実際の提出画面操作**

```
【図3-8：AtCoder提出画面の詳細】

┌─────────────────────────────────────────────┐
│ 🏆 ABC001 A - 積雪深差                        │
├─────────────────────────────────────────────┤
│ 📝 言語選択: [Python (3.8.2) ▼]              │
│ 📄 ソースコード:                              │
│ ┌─────────────────────────────────────────┐ │
│ │ h1 = int(input())                       │ │
│ │ h2 = int(input())                       │ │
│ │ print(h2 - h1)                          │ │
│ │                                         │ │
│ └─────────────────────────────────────────┘ │
│                                           │
│ 🔍 提出前チェックポイント:                   │
│ ✅ 言語が Python になっているか             │
│ ✅ インデントが正しいか                     │
│ ✅ 不要な print文がないか                  │
│ ✅ input() の数が問題文と一致するか          │
│                                           │
│            [提出]  [リセット]               │
└─────────────────────────────────────────────┘
```

### 3.5 デバッグの基本を覚えよう

**中学生向けデバッグマインドセット**

```
【図3-9：デバッグの心構え】

❌ 避けるべき考え方          ✅ 正しい考え方
┌─────────────────┐      ┌─────────────────┐
│「また間違えた...」      │  →  │「何かを学ぶチャンス！」 │
│「自分はダメだ...」      │  →  │「成長のための練習」   │
│「すぐに諦めよう」      │  →  │「少しずつ改善しよう」 │
└─────────────────┘      └─────────────────┘

🔍 デバッグは探偵ゲーム！
「コンピュータがなぜそう動いたのか」を推理する楽しいゲーム
```

**実践的デバッグテクニック**

```
【図3-10：print文を使ったデバッグ技法】

問題のあるコード例：
┌─────────────────────────────────────────────┐
│ n = int(input())                              │
│ total = 0                                     │
│ for i in range(n):                            │
│     x = int(input())                          │
│     total += x                                │
│ print(total * 2)  # なぜか答えが違う...        │
└─────────────────────────────────────────────┘

デバッグ版（print文追加）：
┌─────────────────────────────────────────────┐
│ n = int(input())                              │
│ print(f"n = {n}")  # 👈 確認用                │
│ total = 0                                     │
│ for i in range(n):                            │
│     x = int(input())                          │
│     print(f"i={i}, x={x}")  # 👈 確認用        │
│     total += x                                │
│     print(f"total={total}")  # 👈 確認用       │
│ print(f"最終total = {total}")  # 👈 確認用     │
│ print(total * 2)                              │
└─────────────────────────────────────────────┘

🕵️ デバッグの流れ：
1. 変数の値を確認
2. 計算過程を追跡  
3. 期待値と実際の値を比較
4. 問題箇所を特定
5. 修正して再テスト
```

---

## 第4章：入出力処理を完全マスター

### 章の目的
競技プログラミングで最も重要な基礎技術である入出力処理を確実に習得する

### 4.1 入力って何？出力って何？

**Scratchとの対比による理解**

```
【図4-1：ScratchとPythonの入出力対比】

🎮 Scratchでの入出力        💻 Pythonでの入出力
┌─────────────────┐      ┌─────────────────┐
│ 👤「名前は？」と聞く     │      │ name = input()      │
│ 📝 答えを変数に保存     │  ⟷   │ # ユーザーの入力を待つ │
│ 💬「こんにちは○○」と言う │      │ print(f"こんにちは{name}")│
└─────────────────┘      └─────────────────┘

💡 本質は同じ：
• 外部から情報を受け取る（入力）
• 処理した結果を外部に伝える（出力）
```

**競技プログラミングでの入出力の特殊性**

```
【図4-2：一般プログラムと競技プログラムの入出力の違い】

🖥️ 一般的なプログラム      🏆 競技プログラミング
┌─────────────────┐      ┌─────────────────┐
│ ユーザーとの対話形式    │      │ 一方通行の処理      │
│「名前は？」→入力        │      │ 問題文で形式決定    │
│「年齢は？」→入力        │  VS  │ 標準入力→計算→標準出力│
│ エラー時は再入力要求    │      │ 1回で正確に処理     │
│ ユーザビリティ重視     │      │ 効率と正確性重視    │
└─────────────────┘      └─────────────────┘

競技プログラミングの入出力ルール：
✅ 問題文で入力形式が完全に指定される
✅ 出力形式も厳密に指定される（改行、スペースまで）
✅ エラーハンドリングは不要（入力は保証される）
✅ 対話的な処理は基本的になし
```

### 4.2 1つの数字を読み込もう

**基本パターンの完全理解**

```
【図4-3：単一数値入力の内部処理フロー】

標準入力: "42\n"
    ↓
input()関数: "42"（文字列として取得）
    ↓
int()関数: 42（整数として変換）
    ↓
変数に格納: n = 42

コード例とその動作：
┌─────────────────────────────────────────────┐
│ # 入力例：42                                 │
│ n = int(input())                              │
│                                             │
│ 内部では以下が起こっている：                  │
│ 1. input() → "42" を返す                    │
│ 2. int("42") → 42 を返す                    │
│ 3. n = 42 が確定                            │
│                                             │
│ print(n)      # 42 が出力される              │
│ print(n * 2)  # 84 が出力される              │
└─────────────────────────────────────────────┘
```

**よくある間違いとその対策**

```
【図4-4：単一入力でのよくある間違いパターン】

❌ 間違い1：int()を忘れる
┌─────────────────────────────────────────────┐
│ n = input()  # nは"42"（文字列）              │
│ print(n * 2) # "4242"が出力される（文字列結合）│
└─────────────────────────────────────────────┘

❌ 間違い2：不要な変換
┌─────────────────────────────────────────────┐
│ n = int(input())                              │
│ print(str(n))  # 不要なstr()変換              │
└─────────────────────────────────────────────┘

✅ 正しいパターン
┌─────────────────────────────────────────────┐
│ n = int(input())  # 整数として読み込み        │
│ print(n)          # そのまま出力可能          │
└─────────────────────────────────────────────┘
```

### 4.3 複数の数字を読み込もう

**split()とmap()の組み合わせの理解**

```
【図4-5：複数数値入力の段階的処理】

入力: "3 5 2\n"
    ↓
input(): "3 5 2"
    ↓
.split(): ["3", "5", "2"]（文字列のリスト）
    ↓
map(int, ...): [3, 5, 2]（整数のイテレータ）
    ↓
代入パターン:

パターン1：個別変数に代入
a, b, c = map(int, input().split())
# a=3, b=5, c=2

パターン2：リストとして取得
numbers = list(map(int, input().split()))
# numbers = [3, 5, 2]
```

**実践的な使い分け**

```
【図4-6：複数入力の使い分けガイド】

📝 2-3個の値 → 個別変数
┌─────────────────────────────────────────────┐
│ # 座標を読み込む場合                          │
│ x, y = map(int, input().split())              │
│ print(f"点({x}, {y})")                       │
│                                             │
│ # 範囲を読み込む場合                          │
│ start, end = map(int, input().split())        │
│ for i in range(start, end + 1):              │
│     print(i)                                │
└─────────────────────────────────────────────┘

📝 多数の値 → リスト
┌─────────────────────────────────────────────┐
│ # N個の点数を読み込む場合                     │
│ n = int(input())                              │
│ scores = list(map(int, input().split()))      │
│ print(f"平均: {sum(scores) / len(scores)}")   │
│                                             │
│ # 可変個数の場合                             │
│ data = list(map(int, input().split()))        │
│ print(f"最大値: {max(data)}")                │
└─────────────────────────────────────────────┘
```

### 4.4 繰り返し入力を処理しよう

**N行入力の標準パターン**

```
【図4-7：N行入力処理の基本形】

問題例：「N個の整数が1行ずつ与えられる」

入力例:
3      ← N（行数）
10     ← 1行目の数値
25     ← 2行目の数値  
13     ← 3行目の数値

基本コード：
┌─────────────────────────────────────────────┐
│ n = int(input())          # 行数を読み込み    │
│ numbers = []              # 結果格納用リスト  │
│ for i in range(n):        # N回繰り返し      │
│     x = int(input())      # 1行ずつ読み込み   │
│     numbers.append(x)     # リストに追加     │
│                                             │
│ # この時点で numbers = [10, 25, 13]         │
│ print(max(numbers))       # 最大値出力       │
└─────────────────────────────────────────────┘
```

**リスト内包表記による効率化**

```
【図4-8：リスト内包表記の活用】

基本形 → 内包表記への変換

❌ 冗長な書き方：
┌─────────────────────────────────────────────┐
│ n = int(input())                              │
│ numbers = []                                  │
│ for i in range(n):                            │
│     numbers.append(int(input()))              │
└─────────────────────────────────────────────┘

✅ 内包表記（推奨）：
┌─────────────────────────────────────────────┐
│ n = int(input())                              │
│ numbers = [int(input()) for _ in range(n)]    │
└─────────────────────────────────────────────┘

💡 なぜ"_"を使う？
• iという変数を使わない場合の慣習
• 「カウンタは必要だが、値は使わない」の意味
```

### 4.5 文字列入力を扱おう

**文字列処理の基本パターン**

```
【図4-9：文字列入力の処理方法】

基本的な文字列入力：
┌─────────────────────────────────────────────┐
│ s = input()                # 1行を文字列として│
│ print(len(s))             # 文字数を出力     │
│ print(s.upper())          # 大文字に変換     │
│ print(s.lower())          # 小文字に変換     │
└─────────────────────────────────────────────┘

文字列の分割と処理：
┌─────────────────────────────────────────────┐
│ # "apple banana cherry"のような入力         │
│ s = input()                                   │
│ words = s.split()         # ['apple', 'banana', 'cherry']│
│ for word in words:                            │
│     print(f"単語: {word}")                   │
└─────────────────────────────────────────────┘

1文字ずつの処理：
┌─────────────────────────────────────────────┐
│ s = input()               # "hello"          │
│ for char in s:           # 1文字ずつ処理      │
│     print(char)          # h, e, l, l, o     │
└─────────────────────────────────────────────┘
```

### 4.6 出力フォーマットをマスターしよう

**print()関数の詳細オプション**

```
【図4-10：print()関数の完全活用】

基本的な使い方：
┌─────────────────────────────────────────────┐
│ print("Hello")            # Hello            │
│ print(42)                # 42               │
│ print(3.14159)           # 3.14159          │
└─────────────────────────────────────────────┘

複数値の出力制御：
┌─────────────────────────────────────────────┐
│ a, b, c = 1, 2, 3                            │
│ print(a, b, c)           # 1 2 3（スペース区切り）│
│ print(a, b, c, sep='-')  # 1-2-3（ハイフン区切り）│
│ print(a, b, c, sep='')   # 123（区切りなし）   │
└─────────────────────────────────────────────┘

改行制御：
┌─────────────────────────────────────────────┐
│ print("A")                                   │
│ print("B")               # A（改行）B         │
│                                             │
│ print("A", end="")                           │ 
│ print("B")               # AB（改行なし）     │
│                                             │
│ print("A", end="-")                          │
│ print("B")               # A-B               │
└─────────────────────────────────────────────┘
```

---

## 第5章：基本アルゴリズムの道具箱

### 章の目的
問題解決のための基本的なアルゴリズムを理解し、適切に選択・実装できるようになる

### 5.1 全探索（しらみつぶし）で解いてみよう

**全探索の考え方（Scratchとの関連）**

```
【図5-1：Scratchのゲーム開発と全探索の関係】

🎮 Scratchでの敵キャラ発見     🔍 競技プログラミングの全探索
┌─────────────────┐      ┌─────────────────┐
│ 画面上の全ての場所を     │      │ 可能な全ての答えを      │
│ 順番にチェック         │  ⟷   │ 順番にチェック         │
│ ↓                    │      │ ↓                    │
│ 敵がいるかどうか確認    │      │ 条件を満たすかどうか確認│
│ ↓                    │      │ ↓                    │
│ 見つかったら処理実行    │      │ 見つかったら答えとして採用│
└─────────────────┘      └─────────────────┘

共通する考え方：「しらみつぶしに調べる」
```

**具体的な全探索の実装**

```
【図5-2：全探索実装パターン】

問題例：「1以上N以下の整数で、各桁の和がKになるものを全て出力」

全探索アプローチ：
┌─────────────────────────────────────────────┐
│ n, k = map(int, input().split())              │
│ for i in range(1, n + 1):    # 1からNまで全チェック│
│     digit_sum = 0                             │
│     temp = i                                  │
│     while temp > 0:          # 各桁の和を計算 │
│         digit_sum += temp % 10                │
│         temp //= 10                           │
│     if digit_sum == k:       # 条件チェック   │
│         print(i)             # 条件満たせば出力│
└─────────────────────────────────────────────┘

💡 全探索が有効な条件：
• 調べる範囲が十分小さい（通常10^6程度まで）
• 他に効率的な方法が思いつかない
• 確実に正解したい（実装が簡単で間違いにくい）
```

### 5.2 条件分岐で場合分けしよう

**複雑な条件分岐の整理法**

```
【図5-3：条件分岐の段階的構築】

問題例：「点数に応じて成績を判定」
90点以上：A, 80点以上：B, 70点以上：C, 60点以上：D, 未満：F

❌ 複雑すぎる条件：
┌─────────────────────────────────────────────┐
│ if score >= 90:                               │
│     grade = "A"                               │
│ elif score >= 80 and score < 90:             │  # 不要な条件
│     grade = "B"                               │
│ elif score >= 70 and score < 80:             │  # 不要な条件
│     grade = "C"                               │
│ # ... 続く                                   │
└─────────────────────────────────────────────┘

✅ 段階的な条件分岐：
┌─────────────────────────────────────────────┐
│ if score >= 90:                               │
│     grade = "A"                               │
│ elif score >= 80:     # 既に90未満が確定      │
│     grade = "B"                               │
│ elif score >= 70:     # 既に80未満が確定      │
│     grade = "C"                               │
│ elif score >= 60:     # 既に70未満が確定      │
│     grade = "D"                               │
│ else:                # 60未満                │
│     grade = "F"                               │
└─────────────────────────────────────────────┘
```

### 5.3 数学の公式を使ってみよう

**最大公約数（GCD）の理解と実装**

```
【図5-4：ユークリッドの互除法の視覚的理解】

例：gcd(48, 18)を求める

Step 1: 48 ÷ 18 = 2 余り 12
┌─────────┬─────────┬─────────┐
│    18   │   18    │   12    │  48を18で割った余り
└─────────┴─────────┴─────────┘

Step 2: 18 ÷ 12 = 1 余り 6  
┌─────────┬─────────┐
│   12    │    6    │  18を12で割った余り
└─────────┴─────────┘

Step 3: 12 ÷ 6 = 2 余り 0
┌─────────┬─────────┐
│    6    │    6    │  12を6で割った余り
└─────────┴─────────┘

余りが0になったので、gcd(48, 18) = 6

実装：
┌─────────────────────────────────────────────┐
│ def gcd(a, b):                                │
│     while b:                                  │
│         a, b = b, a % b                       │
│     return a                                  │
│                                             │
│ # 使用例                                     │
│ print(gcd(48, 18))  # 6                      │
└─────────────────────────────────────────────┘
```

### 5.4 文字列を操作してみよう

**文字列操作の実践パターン**

```
【図5-5：競技プログラミングでよく使う文字列操作】

パターン1：文字の出現回数カウント
┌─────────────────────────────────────────────┐
│ s = "programming"                             │
│ count = {}                                    │
│ for char in s:                                │
│     count[char] = count.get(char, 0) + 1      │
│ print(count)  # {'p': 1, 'r': 2, 'o': 1, ...}│
└─────────────────────────────────────────────┘

パターン2：回文（palindrome）判定
┌─────────────────────────────────────────────┐
│ s = "racecar"                                 │
│ if s == s[::-1]:                              │
│     print("回文です")                         │
│ else:                                         │
│     print("回文ではありません")                │
└─────────────────────────────────────────────┘

パターン3：文字列の置換・加工
┌─────────────────────────────────────────────┐
│ s = "Hello World"                             │
│ s = s.replace(" ", "_")      # "Hello_World"  │
│ s = s.lower()               # "hello_world"  │
│ words = s.split("_")        # ["hello", "world"]│
└─────────────────────────────────────────────┘
```

### 5.5 ソート（並び替え）を活用しよう

**ソートの基本と応用**

```
【図5-6：Pythonでのソート完全活用】

基本的なソート：
┌─────────────────────────────────────────────┐
│ numbers = [3, 1, 4, 1, 5, 9, 2, 6]           │
│ numbers.sort()              # 元のリストを変更│
│ print(numbers)              # [1, 1, 2, 3, 4, 5, 6, 9]│
│                                             │
│ # または                                     │
│ numbers = [3, 1, 4, 1, 5, 9, 2, 6]           │
│ sorted_nums = sorted(numbers)  # 新しいリスト作成│
│ print(sorted_nums)          # [1, 1, 2, 3, 4, 5, 6, 9]│
└─────────────────────────────────────────────┘

逆順ソート：
┌─────────────────────────────────────────────┐
│ numbers = [3, 1, 4, 1, 5, 9, 2, 6]           │
│ numbers.sort(reverse=True)   # 降順ソート    │
│ print(numbers)              # [9, 6, 5, 4, 3, 2, 1, 1]│
└─────────────────────────────────────────────┘

カスタムソート（応用）：
┌─────────────────────────────────────────────┐
│ # 文字列を長さでソート                        │
│ words = ["apple", "cat", "banana", "dog"]     │
│ words.sort(key=len)                           │
│ print(words)  # ['cat', 'dog', 'apple', 'banana']│
│                                             │
│ # 絶対値でソート                             │
│ numbers = [-3, 1, -4, 2, 5]                   │
│ numbers.sort(key=abs)                         │
│ print(numbers)  # [1, 2, -3, -4, 5]          │
└─────────────────────────────────────────────┘
```

### 5.6 貪欲法（グリーディ）で最適解を見つけよう

**貪欲法の基本的な考え方**

```
【図5-7：貪欲法の思考プロセス】

問題例：「コインを使って目標金額を作る。使うコインの枚数を最小にしたい」
利用可能コイン：500円、100円、50円、10円、1円

目標：890円を作る

貪欲アルゴリズム：
┌─────────────────────────────────────────────┐
│ Step 1: 500円を使えるだけ使う                 │
│ 890 ÷ 500 = 1枚, 残り390円                  │
│                                             │
│ Step 2: 100円を使えるだけ使う                 │
│ 390 ÷ 100 = 3枚, 残り90円                   │
│                                             │
│ Step 3: 50円を使えるだけ使う                  │
│ 90 ÷ 50 = 1枚, 残り40円                     │
│                                             │
│ Step 4: 10円を使えるだけ使う                  │
│ 40 ÷ 10 = 4枚, 残り0円                      │
│                                             │
│ 合計：1+3+1+4 = 9枚                         │
└─────────────────────────────────────────────┘

実装：
┌─────────────────────────────────────────────┐
│ target = 890                                  │
│ coins = [500, 100, 50, 10, 1]                │
│ count = 0                                     │
│                                             │
│ for coin in coins:                            │
│     count += target // coin                   │
│     target %= coin                            │
│                                             │
│ print(count)  # 9                            │
└─────────────────────────────────────────────┘
```

---

## 第6章：データ構造を理解して活用しよう

### 章の目的
効率的なデータ管理と操作のための基本的なデータ構造を理解し、問題に応じて適切に選択できるようになる

### 6.1 リスト（配列）を使いこなそう

**リストの内部構造と操作の理解**

```
【図6-1：リストのメモリ構造イメージ】

numbers = [10, 25, 7, 33, 2]

メモリ上でのイメージ：
┌─────┬─────┬─────┬─────┬─────┐
│ 10  │ 25  │  7  │ 33  │  2  │
└─────┴─────┴─────┴─────┴─────┘
  [0]   [1]   [2]   [3]   [4]   ← インデックス

主な操作：
┌─────────────────────────────────────────────┐
│ # 要素へのアクセス                            │
│ print(numbers[0])     # 10                   │
│ print(numbers[-1])    # 2（末尾要素）         │
│                                             │
│ # 要素の追加                                 │
│ numbers.append(99)    # 末尾に追加           │
│ numbers.insert(1, 15) # インデックス1に挿入   │
│                                             │
│ # 要素の削除                                 │
│ numbers.remove(25)    # 値25を削除           │
│ del numbers[0]        # インデックス0を削除   │
│                                             │
│ # スライス操作                               │
│ print(numbers[1:4])   # インデックス1-3の部分│
└─────────────────────────────────────────────┘
```

**二次元リストの活用**

```
【図6-2：二次元リストの構造と使用例】

grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

視覚的表現：
  0   1   2   ← 列インデックス
0 1   2   3
1 4   5   6
2 7   8   9
↑ 行インデックス

アクセス方法：
┌─────────────────────────────────────────────┐
│ print(grid[0][0])     # 1                    │
│ print(grid[1][2])     # 6                    │
│ print(grid[2][1])     # 8                    │
│                                             │
│ # 行単位での処理                             │
│ for row in grid:                              │
│     print(sum(row))   # 各行の合計           │
│                                             │
│ # 全要素への処理                             │
│ for i in range(len(grid)):                    │
│     for j in range(len(grid[i])):             │
│         print(f"({i},{j}): {grid[i][j]}")     │
└─────────────────────────────────────────────┘

初期化のテクニック：
┌─────────────────────────────────────────────┐
│ # 3x3のゼロ行列                              │
│ matrix = [[0] * 3 for _ in range(3)]          │
│                                             │
│ # 5x4の初期値1行列                           │
│ matrix = [[1] * 4 for _ in range(5)]          │
│                                             │
│ ❌ 危険な初期化（避けるべき）：                │
│ matrix = [[0] * 3] * 3  # 参照の共有で問題発生│
└─────────────────────────────────────────────┘
```

### 6.2 辞書（ディクショナリ）で高速検索

**辞書の基本概念と活用法**

```
【図6-3：辞書によるデータ管理】

従来のリスト検索 vs 辞書検索：

❌ リストでの検索（効率悪い）：
┌─────────────────────────────────────────────┐
│ students = ["Alice", "Bob", "Charlie", "David"]│
│ scores = [85, 92, 78, 90]                     │
│                                             │
│ # "Bob"の点数を知りたい場合                   │
│ for i, name in enumerate(students):           │
│     if name == "Bob":                         │
│         print(scores[i])  # 92               │
│         break                                 │
└─────────────────────────────────────────────┘

✅ 辞書での検索（効率的）：
┌─────────────────────────────────────────────┐
│ scores = {"Alice": 85, "Bob": 92, "Charlie": 78, "David": 90}│
│                                             │
│ # "Bob"の点数を知りたい場合                   │
│ print(scores["Bob"])      # 92（即座に取得） │
└─────────────────────────────────────────────┘
```

**辞書の実践的な使用パターン**

```
【図6-4：競技プログラミングでの辞書活用例】

パターン1：カウント処理
┌─────────────────────────────────────────────┐
│ text = "programming"                          │
│ char_count = {}                               │
│ for char in text:                             │
│     char_count[char] = char_count.get(char, 0) + 1│
│ print(char_count)                             │
│ # {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1}│
└─────────────────────────────────────────────┘

パターン2：グループ分け
┌─────────────────────────────────────────────┐
│ students = [("Alice", "A"), ("Bob", "B"), ("Charlie", "A")]│
│ groups = {}                                   │
│ for name, grade in students:                  │
│     if grade not in groups:                   │
│         groups[grade] = []                    │
│     groups[grade].append(name)                │
│ print(groups)                                 │
│ # {'A': ['Alice', 'Charlie'], 'B': ['Bob']}  │
└─────────────────────────────────────────────┘

パターン3：メモ化（高速化テクニック）
┌─────────────────────────────────────────────┐
│ memo = {}                                     │
│ def fibonacci(n):                             │
│     if n in memo:                             │
│         return memo[n]                        │
│     if n <= 1:                                │
│         return n                              │
│     memo[n] = fibonacci(n-1) + fibonacci(n-2) │
│     return memo[n]                            │
└─────────────────────────────────────────────┘
```

#以下、続きの章のラフ原稿は次のartifactで作成します...
